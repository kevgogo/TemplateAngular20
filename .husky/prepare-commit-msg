# Genera t√≠tulos y descripciones autom√°ticas con contadores y listados de archivos

set +e  # No abortar por comandos que fallen

MSG_FILE="${1:-}"
SOURCE="${2:-}"
SHA="${3:-}"

# No tocar mensajes de merge/squash/revert
case "$SOURCE" in
  merge|squash|revert) exit 0 ;;
esac

# ============= OBTENER CONTEXTO =============
BRANCH="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'main')"
TICKET="$(echo "$BRANCH" | grep -Eo '[A-Z]{2,}-[0-9]+' | head -n1)"
CHANGES="$(git diff --cached --name-status -M -C --no-color 2>/dev/null)"

# Contadores de archivos
ADDED_COUNT=0
MODIFIED_COUNT=0
DELETED_COUNT=0
RENAMED_COUNT=0

# Listas de archivos
ADDED_FILES=""
MODIFIED_FILES=""
DELETED_FILES=""
RENAMED_FILES=""

# Procesar cambios
if [ -n "$CHANGES" ]; then
  while IFS="$(printf '\t')" read -r status file_a file_b; do
    case "$status" in
      A)
        ADDED_COUNT=$((ADDED_COUNT + 1))
        ADDED_FILES="${ADDED_FILES}\n  - ${file_a}"
        ;;
      M|T)
        MODIFIED_COUNT=$((MODIFIED_COUNT + 1))
        MODIFIED_FILES="${MODIFIED_FILES}\n  - ${file_a}"
        ;;
      D)
        DELETED_COUNT=$((DELETED_COUNT + 1))
        DELETED_FILES="${DELETED_FILES}\n  - ${file_a}"
        ;;
      R*)
        RENAMED_COUNT=$((RENAMED_COUNT + 1))
        RENAMED_FILES="${RENAMED_FILES}\n  - ${file_a} ‚Üí ${file_b}"
        ;;
      C*)
        ADDED_COUNT=$((ADDED_COUNT + 1))
        ADDED_FILES="${ADDED_FILES}\n  - ${file_b:-$file_a} (copiado)"
        ;;
    esac
  done <<EOF
$CHANGES
EOF
fi

TOTAL_FILES=$((ADDED_COUNT + MODIFIED_COUNT + DELETED_COUNT + RENAMED_COUNT))

# ============= DETECCI√ìN DE TIPO =============
detect_type() {
  # Por nombre de rama
  case "$BRANCH" in
    fix/*|hotfix/*|bugfix/*) echo "fix" && return ;;
    feat/*|feature/*) echo "feat" && return ;;
    docs/*|doc/*) echo "docs" && return ;;
    style/*|styles/*) echo "style" && return ;;
    refactor/*) echo "refactor" && return ;;
    perf/*|performance/*) echo "perf" && return ;;
    test/*|tests/*) echo "test" && return ;;
    build/*) echo "build" && return ;;
    ci/*) echo "ci" && return ;;
    chore/*|task/*) echo "chore" && return ;;
  esac

  # Por archivos modificados
  STAGED_LIST="$(git diff --name-only --cached 2>/dev/null)"
  if [ -n "$STAGED_LIST" ]; then
    # Tests
    if echo "$STAGED_LIST" | grep -qE '\.(test|spec)\.|__tests__|\.test\.|\.spec\.'; then
      echo "test" && return
    fi
    
    # Documentaci√≥n
    if echo "$STAGED_LIST" | grep -qE '\.md$|README|CHANGELOG|LICENSE|\.txt$'; then
      echo "docs" && return
    fi
    
    # Estilos
    if echo "$STAGED_LIST" | grep -qE '\.(s?css|less|sass|styl)$|\.html$'; then
      echo "style" && return
    fi
    
    # Build/Config
    if echo "$STAGED_LIST" | grep -qE 'package\.json|package-lock\.json|yarn\.lock|pnpm-lock\.yaml|webpack|vite|rollup|tsconfig|\.config\.|Dockerfile|docker-compose'; then
      echo "build" && return
    fi
    
    # CI
    if echo "$STAGED_LIST" | grep -qE '\.github/|\.gitlab-ci|jenkins|\.travis|\.circleci|azure-pipeline'; then
      echo "ci" && return
    fi
  fi

  # Por defecto
  echo "chore"
}

# ============= DETECCI√ìN DE SCOPE =============
detect_scope() {
  STAGED_LIST="$(git diff --name-only --cached 2>/dev/null)"
  if [ -n "$STAGED_LIST" ]; then
    # Componentes
    if echo "$STAGED_LIST" | grep -q '^src/components/\|^components/'; then
      echo "(components)" && return
    fi
    
    # API/Services
    if echo "$STAGED_LIST" | grep -qE '^src/(services|api)/|^(services|api)/'; then
      echo "(api)" && return
    fi
    
    # Utils
    if echo "$STAGED_LIST" | grep -q '^src/utils/\|^utils/'; then
      echo "(utils)" && return
    fi
    
    # Hooks
    if echo "$STAGED_LIST" | grep -q '^src/hooks/\|^hooks/'; then
      echo "(hooks)" && return
    fi
    
    # UI/Styles
    if echo "$STAGED_LIST" | grep -qE '^src/(ui|styles)/|^(ui|styles)/'; then
      echo "(ui)" && return
    fi
    
    # Config
    if echo "$STAGED_LIST" | grep -qE '^src/config/|^config/|\.config\.|tsconfig|package\.json'; then
      echo "(config)" && return
    fi
    
    # Tests
    if echo "$STAGED_LIST" | grep -qE '__tests__|\.test\.|\.spec\.'; then
      echo "(tests)" && return
    fi
  fi
  
  echo ""  # Sin scope
}

TYPE="$(detect_type)"
SCOPE="$(detect_scope)"

# ============= CONSTRUIR T√çTULO =============
# Leer mensaje existente
EXISTING_HEADER="$(sed -n '1p' "$MSG_FILE" 2>/dev/null | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

# Verificar si ya es un conventional commit
if echo "$EXISTING_HEADER" | grep -qE '^[a-z]+(\([^)]+\))?(!)?: .+'; then
  # Ya es conventional, solo agregar/actualizar contadores y ticket
  TITLE_BASE="$(echo "$EXISTING_HEADER" | sed 's/ \[[A-Z][A-Z]*-[0-9][0-9]*\]//g' | sed 's/ ([0-9].*//g')"
  
  # Construir contadores
  COUNTERS=""
  [ $ADDED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}+${ADDED_COUNT}"
  [ $MODIFIED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}${COUNTERS:+,}~${MODIFIED_COUNT}"
  [ $DELETED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}${COUNTERS:+,}-${DELETED_COUNT}"
  [ $RENAMED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}${COUNTERS:+,}‚Üí${RENAMED_COUNT}"
  
  if [ -n "$COUNTERS" ]; then
    TITLE="${TITLE_BASE} (${COUNTERS})"
  else
    TITLE="$TITLE_BASE"
  fi
  
  # Agregar ticket si existe
  if [ -n "$TICKET" ] && ! echo "$TITLE" | grep -q "$TICKET"; then
    TITLE="${TITLE} [$TICKET]"
  fi
else
  # Crear nuevo t√≠tulo conventional
  SUBJECT="${EXISTING_HEADER:-"actualizaci√≥n de archivos"}"
  
  # Construir contadores
  COUNTERS=""
  [ $ADDED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}+${ADDED_COUNT}"
  [ $MODIFIED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}${COUNTERS:+,}~${MODIFIED_COUNT}"
  [ $DELETED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}${COUNTERS:+,}-${DELETED_COUNT}"
  [ $RENAMED_COUNT -gt 0 ] && COUNTERS="${COUNTERS}${COUNTERS:+,}‚Üí${RENAMED_COUNT}"
  
  if [ -n "$COUNTERS" ]; then
    COUNTER_PART=" (${COUNTERS})"
  else
    COUNTER_PART=""
  fi
  
  # Construir t√≠tulo completo
  if [ -n "$TICKET" ]; then
    TITLE="${TYPE}${SCOPE}: [$TICKET] ${SUBJECT}${COUNTER_PART}"
  else
    TITLE="${TYPE}${SCOPE}: ${SUBJECT}${COUNTER_PART}"
  fi
fi

# ============= CONSTRUIR DESCRIPCI√ìN =============
BODY=""

# Resumen de cambios
if [ $TOTAL_FILES -gt 0 ]; then
  BODY="${BODY}## üìã Resumen de cambios\n\n"
  BODY="${BODY}**Total de archivos afectados:** ${TOTAL_FILES}\n\n"
  
  # Estad√≠sticas por tipo
  [ $ADDED_COUNT -gt 0 ] && BODY="${BODY}- ‚ú® **Agregados:** ${ADDED_COUNT}\n"
  [ $MODIFIED_COUNT -gt 0 ] && BODY="${BODY}- üîß **Modificados:** ${MODIFIED_COUNT}\n"
  [ $DELETED_COUNT -gt 0 ] && BODY="${BODY}- üóëÔ∏è **Eliminados:** ${DELETED_COUNT}\n"
  [ $RENAMED_COUNT -gt 0 ] && BODY="${BODY}- üìù **Renombrados:** ${RENAMED_COUNT}\n"
  
  BODY="${BODY}\n"
fi

# Listado detallado de archivos
if [ -n "$ADDED_FILES" ]; then
  BODY="${BODY}### ‚ú® Archivos agregados\n$(printf '%b' "$ADDED_FILES")\n\n"
fi

if [ -n "$MODIFIED_FILES" ]; then
  BODY="${BODY}### üîß Archivos modificados\n$(printf '%b' "$MODIFIED_FILES")\n\n"
fi

if [ -n "$DELETED_FILES" ]; then
  BODY="${BODY}### üóëÔ∏è Archivos eliminados\n$(printf '%b' "$DELETED_FILES")\n\n"
fi

if [ -n "$RENAMED_FILES" ]; then
  BODY="${BODY}### üìù Archivos renombrados\n$(printf '%b' "$RENAMED_FILES")\n\n"
fi

# Plantilla adicional para el usuario
BODY="${BODY}## üéØ Descripci√≥n del cambio\n\n"
BODY="${BODY}<!-- Describe brevemente qu√© cambios realizaste y por qu√© -->\n\n"
BODY="${BODY}## üß™ Testing\n\n"
BODY="${BODY}- [ ] Pruebas unitarias actualizadas\n"
BODY="${BODY}- [ ] Probado manualmente\n"
BODY="${BODY}- [ ] No requiere testing\n\n"

# Referencias
if [ -n "$TICKET" ]; then
  BODY="${BODY}---\n**Refs:** $TICKET\n"
fi

# ============= ESCRIBIR ARCHIVO =============
{
  printf "%s\n\n" "$TITLE"
  [ -n "$BODY" ] && printf "%b" "$BODY"
} > "$MSG_FILE" 2>/dev/null || true

exit 0
